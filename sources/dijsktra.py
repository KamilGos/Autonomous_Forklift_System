from collections import deque, namedtuple
from collections import defaultdict, deque
from heapq import *


class Dijkstra:
    def Calculate_Dijkstra(self, edges, f, t):
        """Generate shortest path using Dijkstra algorithm
        Args:
            edges ([type]): graph edges
            f (string): starting edge
            t (string): final edge

        Returns:
            [list]: list of edges in shortest path (from f to t)
        """
        g = defaultdict(list)
        for l,r,c in edges:
            g[l].append((c,r))

        q, seen, mins = [(0,f,())], set(), {f: 0}
        while q:
            (cost,v1,path) = heappop(q)
            if v1 not in seen:
                seen.add(v1)
                path += (v1, )
                if v1 == t: return (deque(path))

                for c, v2 in g.get(v1, ()):
                    if v2 in seen: continue
                    prev = mins.get(v2, None)
                    next = cost + c
                    if prev is None or next < prev:
                        mins[v2] = next
                        heappush(q, (next, v2, path))
        return float("inf")

    def Transrofm_Shortest_Path_Ids_To_Corr(self, shortest_path_ids, vor_dict):
        """transform path generated by Dijkstra algorithm to coordiantes
        Args:
            shortest_path_ids ([list]): list of edges ids in shortest path
            vor_dict ([dict]): dictionary with Voronoi diagram and ids
        Returns:
            [list]: transformed list
        """
        corr = []
        for id in shortest_path_ids:
            corr.append(vor_dict.get(id))
        return corr


if __name__=="__main__":
    edges =[("a", "b", 7), ("a", "c", 9),("a", "f", 14), ("b", "c", 10), ("b", "d", 15), ("c", "d", 11), ("c", "f", 2), ("d", "e", 6),("e", "f", 9)]
    edges2 = [("a", "b", 7), ("a", "c", 9), ("g", "f", 14)]
    Dijkstra = Dijkstra()
    print(Dijkstra.Calculate_Dijkstra(edges, "a", "f"))
    